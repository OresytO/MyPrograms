<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>12.7.&nbsp;Handling JSF Events With Spring Web Flow</title><link rel="stylesheet" href="css/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><link rel="home" href="index.html" title="Spring Web Flow 2 Reference Guide"><link rel="up" href="ch12.html" title="12.&nbsp;JSF Integration"><link rel="prev" href="ch12s06.html" title="12.6.&nbsp;Replacing the JSF Managed Bean Facility"><link rel="next" href="ch12s08.html" title="12.8.&nbsp;Enhancing The User Experience With Rich Web Forms"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.7.&nbsp;Handling JSF Events With Spring Web Flow</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch12s06.html">Prev</a>&nbsp;</td><th width="60%" align="center">12.&nbsp;JSF Integration</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch12s08.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-faces-event-handling"></a>12.7.&nbsp;Handling JSF Events With Spring Web Flow</h2></div></div></div><p>
            Spring Web Flow allows you to handle JSF action events in a decoupled way, requiring no direct dependencies
            in your Java code on JSF API's. In fact, these events can often be handled completely in the flow definiton
            language without requiring any custom Java action code at all. This allows for a more agile development
            process since the artifacts being manipulated in wiring up events (JSF view templates and SWF flow
            definitions) are instantly refreshable without requiring a build and re-deploy of the whole application.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spring-faces-in-page-events"></a>12.7.1.&nbsp;Handling JSF In-page Action Events</h3></div></div></div><p>
                A simple but common case in JSF is the need to signal an event that causes manipulation of the model in
                some way and then redisplays the same view to reflect the changed state of the model. The flow
                definition language has special support for this in the
                <code class="code">transition</code>
                element.
            </p><p>
                A good example of this is a table of paged list results. Suppose you want to be able to load and display
                only a portion of a large result list, and allow the user to page through the results. The initial
                <code class="code">view-state</code>
                definition to load and display the list would be:
            </p><pre class="programlisting"> 
&lt;<span class="hl-tag">view-state</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reviewHotels"</span>&gt;
    &lt;<span class="hl-tag">on-render</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"bookingService.findHotels(searchCriteria)"</span> 
                  <span class="hl-attribute">result</span>=<span class="hl-value">"viewScope.hotels"</span> <span class="hl-attribute">result-type</span>=<span class="hl-value">"dataModel"</span> /&gt;
    &lt;<span class="hl-tag">/on-render</span>&gt;
&lt;<span class="hl-tag">/view-state</span>&gt;
            </pre><p>
                You construct a JSF DataTable that displays the current
                <code class="code">hotels</code>
                list, and then place a "More Results" link below the table:
            </p><pre class="programlisting"> 
&lt;<span class="hl-tag">h:commandLink</span> <span class="hl-attribute">id</span>=<span class="hl-value">"nextPageLink"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"More Results"</span> <span class="hl-attribute">action</span>=<span class="hl-value">"next"</span>/&gt;
            </pre><p>
                This commandLink signals a "next" event from its action attribute. You can then handle the event by
                adding to the
                <code class="code">view-state</code>
                definition:
            </p><pre class="programlisting"> 
&lt;<span class="hl-tag">view-state</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reviewHotels"</span>&gt;
    &lt;<span class="hl-tag">on-render</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"bookingService.findHotels(searchCriteria)"</span> 
            <span class="hl-attribute">result</span>=<span class="hl-value">"viewScope.hotels"</span> <span class="hl-attribute">result-type</span>=<span class="hl-value">"dataModel"</span> /&gt;
    &lt;<span class="hl-tag">/on-render</span>&gt;
    &lt;<span class="hl-tag">transition</span> <span class="hl-attribute">on</span>=<span class="hl-value">"next"</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"searchCriteria.nextPage()"</span> /&gt;
    &lt;<span class="hl-tag">/transition</span>&gt;
&lt;<span class="hl-tag">/view-state</span>&gt;
            </pre><p>
                Here you handle the "next" event by incrementing the page count on the searchCriteria instance. The
                <code class="code">on-render</code>
                action is then called again with the updated criteria, which causes the next page of results to be
                loaded into the DataModel. The same view is re-rendered since there was no
                <code class="code">to</code>
                attribute on the
                <code class="code">transition</code>
                element, and the changes in the model are reflected in the view.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spring-faces-action-events"></a>12.7.2.&nbsp;Handling JSF Action Events</h3></div></div></div><p>
                The next logical level beyond in-page events are events that require navigation to another view, with
                some manipulation of the model along the way. Achieving this with pure JSF would require adding a
                navigation rule to faces-config.xml and likely some intermediary Java code in a JSF managed bean (both
                tasks requiring a re-deploy). With the flow defintion language, you can handle such a case concisely in
                one place in a quite similar way to how in-page events are handled.
            </p><p>
                Continuing on with our use case of manipulating a paged list of results, suppose we want each row in the
                displayed DataTable to contain a link to a detail page for that row instance. You can add a column to
                the table containing the following
                <code class="code">commandLink</code>
                component:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">h:commandLink</span> <span class="hl-attribute">id</span>=<span class="hl-value">"viewHotelLink"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"View Hotel"</span> <span class="hl-attribute">action</span>=<span class="hl-value">"select"</span>/&gt;
            </pre><p>
                This raises the "select" event which you can then handle by adding another
                <code class="code">transition</code>
                element to the existing
                <code class="code">view-state</code>
                :
            </p><pre class="programlisting"> 
&lt;<span class="hl-tag">view-state</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reviewHotels"</span>&gt;
    &lt;<span class="hl-tag">on-render</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"bookingService.findHotels(searchCriteria)"</span> 
            <span class="hl-attribute">result</span>=<span class="hl-value">"viewScope.hotels"</span> <span class="hl-attribute">result-type</span>=<span class="hl-value">"dataModel"</span> /&gt;
    &lt;<span class="hl-tag">/on-render</span>&gt;
    &lt;<span class="hl-tag">transition</span> <span class="hl-attribute">on</span>=<span class="hl-value">"next"</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"searchCriteria.nextPage()"</span> /&gt;
    &lt;<span class="hl-tag">/transition</span>&gt;
    &lt;<span class="hl-tag">transition</span> <span class="hl-attribute">on</span>=<span class="hl-value">"select"</span> <span class="hl-attribute">to</span>=<span class="hl-value">"reviewHotel"</span>&gt;
            &lt;<span class="hl-tag">set</span> <span class="hl-attribute">name</span>=<span class="hl-value">"flowScope.hotel"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"hotels.selectedRow"</span> /&gt;
    &lt;<span class="hl-tag">/transition</span>&gt;
&lt;<span class="hl-tag">/view-state</span>&gt;
            </pre><p>
                Here the "select" event is handled by pushing the currently selected hotel instance from the DataTable
                into flow scope, so that it may be referenced by the "reviewHotel"
                <code class="code">view-state</code>
                .
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spring-faces-model-validation"></a>12.7.3.&nbsp;Performing Model Validation</h3></div></div></div><p>
                JSF provides useful facilities for validating input at field-level before changes are applied to the
                model, but when you need to then perform more complex validation at the model-level after the updates
                have been applied, you are generally left with having to add more custom code to your JSF action methods
                in the managed bean. Validation of this sort is something that is generally a responsibility of the
                domain model itself, but it is difficult to get any error messages propagated back to the view without
                introducing an undesirable dependency on the JSF API in your domain layer.
            </p><p>
                With Spring Faces, you can utilize the generic and low-level
                <code class="code">MessageContext</code>
                in your business code and any messages added there will then be available to the
                <code class="code">FacesContext</code>
                at render time.
            </p><p>
                For example, suppose you have a view where the user enters the necessary details to complete a hotel
                booking, and you need to ensure the Check In and Check Out dates adhere to a given set of business
                rules. You can invoke such model-level validation from a
                <code class="code">transition</code>
                element:
            </p><pre class="programlisting"> 
&lt;<span class="hl-tag">view-state</span> <span class="hl-attribute">id</span>=<span class="hl-value">"enterBookingDetails"</span>&gt;
    &lt;<span class="hl-tag">transition</span> <span class="hl-attribute">on</span>=<span class="hl-value">"proceed"</span> <span class="hl-attribute">to</span>=<span class="hl-value">"reviewBooking"</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"booking.validateEnterBookingDetails(messageContext)"</span> /&gt;
    &lt;<span class="hl-tag">/transition</span>&gt;
&lt;<span class="hl-tag">/view-state</span>&gt;
            </pre><p>
                Here the "proceed" event is handled by invoking a model-level validation method on the booking instance,
                passing the generic
                <code class="code">MessageContext</code>
                instance so that messages may be recorded. The messages can then be displayed along with any other JSF
                messages with the
                <code class="code">h:messages</code>
                component,
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spring-faces-ajax-events"></a>12.7.4.&nbsp;Handling Ajax Events</h3></div></div></div><p>
                Spring Faces provides some special
                <code class="code">UICommand</code>
                components that go beyond the standard JSF components by adding the ability to do Ajax-based partial
                view updates. These components degrade gracefully so that the flow will still be fully functional by
                falling back to full page refreshes if a user with a less capable browser views the page.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                    Though the core JSF support in Spring Faces is JSF 1.1-compatible, the Spring Faces 
                    Ajax components require JSF 1.2.
                </td></tr></table></div><p>
            </p><p>
                Revisiting the earlier example with the paged table, you can change the "More Results" link to use an
                Ajax request by replacing the standard
                <code class="code">commandButton</code>
                with the Spring Faces version (note that the Spring Faces command components use Ajax by default, but
                they can alternately be forced to use a normal form submit by setting ajaxEnabled="false" on the
                component):
            </p><pre class="programlisting">            
&lt;<span class="hl-tag">sf:commandLink</span> <span class="hl-attribute">id</span>=<span class="hl-value">"nextPageLink"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"More Results"</span> <span class="hl-attribute">action</span>=<span class="hl-value">"next"</span> /&gt;
            </pre><p>
                This event is handled just as in the non-Ajax case with the
                <code class="code">transition</code>
                element, but now you will add a special
                <code class="code">render</code>
                action that specifies which portions of the component tree need to be re-rendered:
            </p><pre class="programlisting">
&lt;view-state id="reviewHotels"&gt;
    &lt;on-render&gt;
        &lt;evaluate expression="bookingService.findHotels(searchCriteria)" 
                  result="viewScope.hotels" result-type="dataModel" /&gt;
    &lt;/on-render&gt;
    &lt;transition on="next"&gt;
        &lt;evaluate expression="searchCriteria.nextPage()" /&gt;
        &lt;render fragments="hotels:searchResultsFragment" /&gt;
    &lt;/transition&gt;
&lt;/view-state&gt;
            </pre><p>
                The
                <code class="code">fragments="hotels:searchResultsFragment"</code>
                is an instruction that will be interpreted at render time, such that only the component with the JSF
                clientId "hotels:searchResultsFragment" will be rendered and returned to the client. This fragment will
                then be automatically replaced in the page. The
                <code class="code">fragments</code>
                attribute can be a comma-delimited list of ids, with each id representing the root node of a subtree
                (meaning the root node and all of its children) to be rendered. If the "next" event is fired in a
                non-Ajax request (i.e., if JavaScript is disabled on the client), the
                <code class="code">render</code>
                action will be ignored and the full page will be rendered as normal.
            </p><p>
                In addition to the Spring Faces
                <code class="code">commandLink</code>
                component, there is a corresponding
                <code class="code">commandButton</code>
                component with the same functionality. There is also a special
                <code class="code">ajaxEvent</code>
                component that will raise a JSF action even in response to any client-side DOM event. See the Spring
                Faces tag library docs for full details.
            </p><p>
                An additional built-in feature when using the Spring Faces Ajax components is the ability to have the
                response rendered inside a rich modal popup widget by setting
                <code class="code">popup="true"</code>
                on a
                <code class="code">view-state</code>
                .
            </p><pre class="programlisting">
&lt;<span class="hl-tag">view-state</span> <span class="hl-attribute">id</span>=<span class="hl-value">"changeSearchCriteria"</span> <span class="hl-attribute">view</span>=<span class="hl-value">"enterSearchCriteria.xhtml"</span> <span class="hl-attribute">popup</span>=<span class="hl-value">"true"</span>&gt;
    &lt;<span class="hl-tag">on-entry</span>&gt;
        &lt;<span class="hl-tag">render</span> <span class="hl-attribute">fragments</span>=<span class="hl-value">"hotelSearchFragment"</span> /&gt;
    &lt;<span class="hl-tag">/on-entry</span>&gt;
    &lt;<span class="hl-tag">transition</span> <span class="hl-attribute">on</span>=<span class="hl-value">"search"</span> <span class="hl-attribute">to</span>=<span class="hl-value">"reviewHotels"</span>&gt;
        &lt;<span class="hl-tag">evaluate</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"searchCriteria.resetPage()"</span>/&gt;
    &lt;<span class="hl-tag">/transition</span>&gt;
&lt;<span class="hl-tag">/view-state</span>&gt;
            </pre><p>
                If the "changeSearchCriteria"
                <code class="code">view-state</code>
                is reached as the result of an Ajax-request, the result will be rendered into a rich popup. If
                JavaScript is unavailable, the request will be processed with a full browser refresh, and the
                "changeSearchCriteria" view will be rendered as normal.
            </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch12s06.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch12.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch12s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">12.6.&nbsp;Replacing the JSF Managed Bean Facility&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;12.8.&nbsp;Enhancing The User Experience With Rich Web Forms</td></tr></table></div></body></html>